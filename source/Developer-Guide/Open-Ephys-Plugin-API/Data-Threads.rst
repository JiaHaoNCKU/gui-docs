.. _datathreads:

.. default-domain:: cpp

Data Threads
=====================

.. csv-table:: Data Threads bring data into the signal chain from external hardware.
   :widths: 18, 80

   "*Type*", ":code:`Plugin::Type::DATA_THREAD`"
   "*Base Classes*", ":code:`DataThread`, :code:`DataBuffer`"
   "*Template*", "https://github.com/open-ephys-plugins/data-thread-template"

**Data Threads** are special types of :ref:`processorplugins` that communicate with a data acquisition device whose clock is not synchronized with the GUI's internal processing callbacks. Instead of implementing a :code:`process()` method as a "Source" processor would, a Data Thread must implement an :code:`updateBuffer()` method that is called inside a separate thread. Any available data in this buffer will be automatically copied into the GUI's signal chain for further processing.

Each Data Thread can generate an arbitrary number of data streams, each with an independent sample clock. The only limitations are that each data stream can only have one event "channel" (with up to 64 TTL lines), and the incoming data cannot contain spike events. Provided that the incoming data fits within these limitations, then it is strongly recommended to derive your plugin from a Data Thread, rather than building a Source Processor.

To create a new Data Thread, start with the `Data Thread Template <https://github.com/open-ephys-plugins/data-thread-template>`__ and add code that implements the following method:

.. function:: bool updateBuffer()

   Adds any available data to a buffer (using :code:`DataBuffer::addToBuffer()`. Any data in this buffer will be automatically copied into the GUI's signal chain during the next :code:`process()` callback.

   :returns bool: :code:`true` if communication with the data acquisition device is intact. If the connection to the device is lost, return :code:`false` to terminate acquisition.

The following is an example of a minimal implementation of :code:`DataThread::updateBuffer()`:

.. code-block:: c++

   int raw_samples[MAX_SAMPLES_PER_BUFFER];
   float scaled_samples[MAX_SAMPLES_PER_BUFFER];
   int64 sample_numbers[MAX_SAMPLES_PER_BUFFER];
   uint64 event_codes[MAX_SAMPLES_PER_BUFFER];
   double timestamps[MAX_SAMPLES_PER_BUFFER];
   int64 totalSamples;
   AcquisitionDevice* device;
   DataBuffer* dataBuffer;

   bool CustomDataThread::updateBuffer()
   {

      int numRead = device->readData(raw_samples, event_codes, MAX_SAMPLES_PER_BUFFER);

      for (int i = 0; i < numRead; i++)
      {
         scaled_samples[i] = raw_samples[i] * scale_factor;
         sample_numbers[i] = totalSamples++;
      }

      dataBuffer->addToBuffer(scaled_samples, 
                              sample_numbers, 
                              timestamps, 
                              event_codes,
                              numRead);

      return true;

   }

In order to inform downstream plugins about the channels generated by a Data Thread, the following method must be implemented:

.. function:: void updateSettings(OwnedArray<ContinuousChannel>* continuousChannels, OwnedArray<EventChannel>* eventChannels, OwnedArray<SpikeChannel>* spikeChannels, OwnedArray<DataStream>* sourceStreams, OwnedArray<DeviceInfo>* devices, OwnedArray<ConfigurationObject>* configurationObjects)

   Passes pointers to the Source processor's info objects to the DataThread, to allow them to be configured as needed. Note that only channels that have been added to a :code:`DataStream` object will be registered by downstream processors. And each :code:`DataStream` can only have one :code:`EventChannel` associated with it.


The following is an example of a minimal implementation of :code:`DataThread::updateSettings()`:

.. code-block:: c++

   bool CustomDataThread::updateSettings(OwnedArray<ContinuousChannel>* continuousChannels,
        OwnedArray<EventChannel>* eventChannels,
        OwnedArray<SpikeChannel>* spikeChannels,
        OwnedArray<DataStream>* sourceStreams,
        OwnedArray<DeviceInfo>* devices,
        OwnedArray<ConfigurationObject>* configurationObjects)
   {

      sourceStreams->clear();
      continuousChannels->clear();
      eventChannels->clear();

      DataStream::Settings settings
      {
         "device_stream", // stream name
         "description",   // stream description
         "identifier",    // stream identifier
         30000.0          // stream sample rate
      };

      DataStream* stream = new DataStream(settings);

      sourceStreams->add(stream); // add pointer to owned array

      for (int i = 0; i < numChannels; i++)
      {
         ContinuousChannel::Settings settings{
				ContinuousChannel::Type::ELECTRODE, // channel type
				"CH" + String(i+1), // channel name
				"description",      // channel description
				"identifier",       // channel identifier
				0.195,              // channel bitvolts scaling
				stream              // associated data stream
			};

         continuousChannels->add(new ContinuousChannel(settings));
      }

      EventChannel::Settings settings{
			EventChannel::Type::TTL, // channel type (must be TTL)
			"Device Event Channel",  // channel name
			"description",           // channel description
			"identifier",            // channel identifier
			stream,                  // associated data stream
			8                        // maximum number of TTL lines
		};

      eventChannels->add(new EventChannel(settings));
   }

A Data Thread must also implement the following three methods in order to be complete:

.. function:: bool foundInputSource()

   Called after the plugin has initialized, to determine whether a connection to the data acquisition device has been established.

   :returns bool: :code:`true` if the data source is connected, :code:`false` otherwise.


.. function:: bool startAcquisition()

   Called just before acquisition begins, to signal that Data Thread should start streaming data from its device.

   :returns bool: :code:`false` if there is an error in starting data transfer, which will cancel the request to start data acquisition.
   

.. function:: bool stopAcquisition()

   Called just before acquisition ends, to signal that Data Thread should stop streaming data from its device.

   :returns bool: :code:`false` if there is an error in stopping data transfer (this return value is not currently handled).

In addition, the following virtual methods can be overriden to extend the functionality of a Data Thread:

.. function:: std::unique_ptr<GenericEditor> createEditor(SourceNode* sourceNode)

   Creates a custom editor for a Data Thread. If this method is not implemented, then a default editor will be created. See the :ref:`processorplugins` documentation page for more information about editors. Note that the GUI's built-in :code:`Parameter` class does not currently work with Data Threads.

   :param sourceNode: A pointer to the :code:`SourceNode` object (derived from the :code:`GenericProcessor` class) associated with this Data Thread.


.. function:: void handleBroadcastMessage(String msg)

   Allows the DataThread plugin to respond to messages sent by other processors during acquisition.

   :param msg: The message that was sent. There are no restrictions on how this string will be formatted; each plugin is responsible for parsing this message in the appropriate way.


.. function:: String handleConfigMessage(String msg)

   Allows the DataThread plugin to handle a configuration message (usually sent via the OpenEphysHTTPServer) while acquisition is not active.

   :param msg: The message that was sent. There are no restrictions on how this string will be formatted; each plugin is responsible for parsing this message in the appropriate way.
   :returns String: The response to the sender (e.g., an acknowledgement that the configuration message was handled properly)
|
